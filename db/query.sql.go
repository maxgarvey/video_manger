// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package db

import (
	"context"
)

const addDirectory = `-- name: AddDirectory :one
INSERT INTO directories (path) VALUES (?) RETURNING id, path
`

func (q *Queries) AddDirectory(ctx context.Context, path string) (Directory, error) {
	row := q.db.QueryRowContext(ctx, addDirectory, path)
	var i Directory
	err := row.Scan(&i.ID, &i.Path)
	return i, err
}

const deleteDirectory = `-- name: DeleteDirectory :exec
DELETE FROM directories WHERE id = ?
`

func (q *Queries) DeleteDirectory(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteDirectory, id)
	return err
}

const getVideoByID = `-- name: GetVideoByID :one
SELECT v.id, v.filename, v.directory_id, v.display_name, d.path AS directory_path
FROM videos v
JOIN directories d ON d.id = v.directory_id
WHERE v.id = ?
`

type GetVideoByIDRow struct {
	ID            int64
	Filename      string
	DirectoryID   int64
	DisplayName   string
	DirectoryPath string
}

func (q *Queries) GetVideoByID(ctx context.Context, id int64) (GetVideoByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getVideoByID, id)
	var i GetVideoByIDRow
	err := row.Scan(
		&i.ID,
		&i.Filename,
		&i.DirectoryID,
		&i.DisplayName,
		&i.DirectoryPath,
	)
	return i, err
}

const listDirectories = `-- name: ListDirectories :many
SELECT id, path FROM directories ORDER BY path
`

func (q *Queries) ListDirectories(ctx context.Context) ([]Directory, error) {
	rows, err := q.db.QueryContext(ctx, listDirectories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Directory
	for rows.Next() {
		var i Directory
		if err := rows.Scan(&i.ID, &i.Path); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTags = `-- name: ListTags :many
SELECT id, name FROM tags ORDER BY name
`

func (q *Queries) ListTags(ctx context.Context) ([]Tag, error) {
	rows, err := q.db.QueryContext(ctx, listTags)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tag
	for rows.Next() {
		var i Tag
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTagsByVideo = `-- name: ListTagsByVideo :many
SELECT t.id, t.name FROM tags t
JOIN video_tags vt ON t.id = vt.tag_id
WHERE vt.video_id = ?
ORDER BY t.name
`

func (q *Queries) ListTagsByVideo(ctx context.Context, videoID int64) ([]Tag, error) {
	rows, err := q.db.QueryContext(ctx, listTagsByVideo, videoID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tag
	for rows.Next() {
		var i Tag
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVideos = `-- name: ListVideos :many
SELECT v.id, v.filename, v.directory_id, v.display_name, d.path AS directory_path
FROM videos v
JOIN directories d ON d.id = v.directory_id
ORDER BY COALESCE(NULLIF(v.display_name, ''), v.filename)
`

type ListVideosRow struct {
	ID            int64
	Filename      string
	DirectoryID   int64
	DisplayName   string
	DirectoryPath string
}

func (q *Queries) ListVideos(ctx context.Context) ([]ListVideosRow, error) {
	rows, err := q.db.QueryContext(ctx, listVideos)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListVideosRow
	for rows.Next() {
		var i ListVideosRow
		if err := rows.Scan(
			&i.ID,
			&i.Filename,
			&i.DirectoryID,
			&i.DisplayName,
			&i.DirectoryPath,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVideosByTag = `-- name: ListVideosByTag :many
SELECT v.id, v.filename, v.directory_id, v.display_name, d.path AS directory_path
FROM videos v
JOIN directories d ON d.id = v.directory_id
JOIN video_tags vt ON v.id = vt.video_id
WHERE vt.tag_id = ?
ORDER BY COALESCE(NULLIF(v.display_name, ''), v.filename)
`

type ListVideosByTagRow struct {
	ID            int64
	Filename      string
	DirectoryID   int64
	DisplayName   string
	DirectoryPath string
}

func (q *Queries) ListVideosByTag(ctx context.Context, tagID int64) ([]ListVideosByTagRow, error) {
	rows, err := q.db.QueryContext(ctx, listVideosByTag, tagID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListVideosByTagRow
	for rows.Next() {
		var i ListVideosByTagRow
		if err := rows.Scan(
			&i.ID,
			&i.Filename,
			&i.DirectoryID,
			&i.DisplayName,
			&i.DirectoryPath,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tagVideo = `-- name: TagVideo :exec
INSERT OR IGNORE INTO video_tags (video_id, tag_id) VALUES (?, ?)
`

type TagVideoParams struct {
	VideoID int64
	TagID   int64
}

func (q *Queries) TagVideo(ctx context.Context, arg TagVideoParams) error {
	_, err := q.db.ExecContext(ctx, tagVideo, arg.VideoID, arg.TagID)
	return err
}

const untagVideo = `-- name: UntagVideo :exec
DELETE FROM video_tags WHERE video_id = ? AND tag_id = ?
`

type UntagVideoParams struct {
	VideoID int64
	TagID   int64
}

func (q *Queries) UntagVideo(ctx context.Context, arg UntagVideoParams) error {
	_, err := q.db.ExecContext(ctx, untagVideo, arg.VideoID, arg.TagID)
	return err
}

const updateVideoName = `-- name: UpdateVideoName :exec
UPDATE videos SET display_name = ? WHERE id = ?
`

type UpdateVideoNameParams struct {
	DisplayName string
	ID          int64
}

func (q *Queries) UpdateVideoName(ctx context.Context, arg UpdateVideoNameParams) error {
	_, err := q.db.ExecContext(ctx, updateVideoName, arg.DisplayName, arg.ID)
	return err
}

const upsertTag = `-- name: UpsertTag :one
INSERT INTO tags (name) VALUES (?)
ON CONFLICT (name) DO UPDATE SET name = excluded.name
RETURNING id, name
`

func (q *Queries) UpsertTag(ctx context.Context, name string) (Tag, error) {
	row := q.db.QueryRowContext(ctx, upsertTag, name)
	var i Tag
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const upsertVideo = `-- name: UpsertVideo :one
INSERT INTO videos (filename, directory_id)
VALUES (?, ?)
ON CONFLICT (filename, directory_id) DO UPDATE SET filename = excluded.filename
RETURNING id, filename, directory_id, display_name
`

type UpsertVideoParams struct {
	Filename    string
	DirectoryID int64
}

func (q *Queries) UpsertVideo(ctx context.Context, arg UpsertVideoParams) (Video, error) {
	row := q.db.QueryRowContext(ctx, upsertVideo, arg.Filename, arg.DirectoryID)
	var i Video
	err := row.Scan(
		&i.ID,
		&i.Filename,
		&i.DirectoryID,
		&i.DisplayName,
	)
	return i, err
}
