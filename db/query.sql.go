// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package db

import (
	"context"
)

const addDirectory = `-- name: AddDirectory :one
INSERT INTO directories (path) VALUES (?) RETURNING id, path
`

func (q *Queries) AddDirectory(ctx context.Context, path string) (Directory, error) {
	row := q.db.QueryRowContext(ctx, addDirectory, path)
	var i Directory
	err := row.Scan(&i.ID, &i.Path)
	return i, err
}

const deleteDirectory = `-- name: DeleteDirectory :exec
DELETE FROM directories WHERE id = ?
`

func (q *Queries) DeleteDirectory(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteDirectory, id)
	return err
}

const listDirectories = `-- name: ListDirectories :many
SELECT id, path FROM directories ORDER BY path
`

func (q *Queries) ListDirectories(ctx context.Context) ([]Directory, error) {
	rows, err := q.db.QueryContext(ctx, listDirectories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Directory
	for rows.Next() {
		var i Directory
		if err := rows.Scan(&i.ID, &i.Path); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTags = `-- name: ListTags :many
SELECT id, name FROM tags ORDER BY name
`

func (q *Queries) ListTags(ctx context.Context) ([]Tag, error) {
	rows, err := q.db.QueryContext(ctx, listTags)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tag
	for rows.Next() {
		var i Tag
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTagsByVideo = `-- name: ListTagsByVideo :many
SELECT t.id, t.name FROM tags t
JOIN video_tags vt ON t.id = vt.tag_id
WHERE vt.video_id = ?
ORDER BY t.name
`

func (q *Queries) ListTagsByVideo(ctx context.Context, videoID int64) ([]Tag, error) {
	rows, err := q.db.QueryContext(ctx, listTagsByVideo, videoID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tag
	for rows.Next() {
		var i Tag
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tagVideo = `-- name: TagVideo :exec
INSERT OR IGNORE INTO video_tags (video_id, tag_id) VALUES (?, ?)
`

type TagVideoParams struct {
	VideoID int64
	TagID   int64
}

func (q *Queries) TagVideo(ctx context.Context, arg TagVideoParams) error {
	_, err := q.db.ExecContext(ctx, tagVideo, arg.VideoID, arg.TagID)
	return err
}

const untagVideo = `-- name: UntagVideo :exec
DELETE FROM video_tags WHERE video_id = ? AND tag_id = ?
`

type UntagVideoParams struct {
	VideoID int64
	TagID   int64
}

func (q *Queries) UntagVideo(ctx context.Context, arg UntagVideoParams) error {
	_, err := q.db.ExecContext(ctx, untagVideo, arg.VideoID, arg.TagID)
	return err
}

const updateVideoName = `-- name: UpdateVideoName :exec
UPDATE videos SET display_name = ? WHERE id = ?
`

type UpdateVideoNameParams struct {
	DisplayName string
	ID          int64
}

func (q *Queries) UpdateVideoName(ctx context.Context, arg UpdateVideoNameParams) error {
	_, err := q.db.ExecContext(ctx, updateVideoName, arg.DisplayName, arg.ID)
	return err
}

const upsertTag = `-- name: UpsertTag :one
INSERT INTO tags (name) VALUES (?)
ON CONFLICT (name) DO UPDATE SET name = excluded.name
RETURNING id, name
`

func (q *Queries) UpsertTag(ctx context.Context, name string) (Tag, error) {
	row := q.db.QueryRowContext(ctx, upsertTag, name)
	var i Tag
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}
